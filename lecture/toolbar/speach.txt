[1] Перед нами пример типичного приложения, наверняка, вы все знаете что панелька в самом верху называется статусБар, а панелька следом за ней - экшнбар/тулбар/аппбар, можно называть любыми словами, она не обидится. Почему так много названий и откуда они взялись? Как и многое в IT - сложилось исторически, поэтому вот небольшая историческая справка.

На заре андроида вообще не было ничего похожего на экшн бар, и каждый придумывал что-то своё. Потом, экшн-бар стал неким паттерном, можно даже сказать стандартом,
поскольку он стал появляться во всё большем количестве приложений это позволяло пользователям взаимодействовать с приложениям проще, и ребята из гугла решили, что нужно сделать что-нибудь в сдк, чтобы упростить разработку, и в 3.0 добавили экшн бар, который задавался с помощью темы приложения:

[2] задаём тему и применяем её к апликейшену

[3] теперь в активити можем использовать экшн бар и вот результат
Экшнбар который мы получили, нам создала сама система, мы просто сказали, что хотим, чтобы у наших активити был светлый экшн бар (это мы указали в теме нашего приложения), вроде бы всё просто, минимум кода, но главный минус в том, что мы никак не контролируем экшн бар, кастомизировать его сложно, набор методов для работы с ним весьма ограничен. Затем настал момент, когда гугл решил, что андроид некрасивый, надо всё менять внешний вид и придумал

[4] матириал дизайн, и стало понятно, что существующее решение не годиться для новых гайдлайнов. МатириалДизайн появился с приходом 5.0, тогда же и нашли решение для устаревшего экшн бара - таким решением стал тулбар.
Давайте рассмотрим, как нам предлагается его использовать.

[5] поменяли тему на ноу экшн бар, говорим системе, что нам от неё не нужно экшн бара, мы о нём сами позаботимся. Ну а чтобы позаботиться, добавим тулбар в нашу активити сами - в разметке.

[6] теперь можно использовать наш тулбар в активити, результат видим абсолютно тотже. Но тулбар мы разместили в разметке сами, это позволяет нам самим решать где на экране должен находиться тулбар и какая должна быть иерархия вьюшек на этом экране, можно даже применить к нему анимацию.

Спросить что такое саппорт либрари, и если не знают, то рассказать.

[7] Посмотрите на этот пример кода, как вы думаете, что произойдёт по выполнению этого куска кода? Тайтл будет иметь значение New title, т.е. мы используем тулбар, но и экшн бар у нас тоже есть. Если мы не будем использовать setSupportActionBar(toolbar), то, логично, getSupportActionBar() вернёт null. Это не очень удобно и иногда приводит к путанице, но этот метод метод очень важен, когда мы передаем активити наш тулбар, она использует его как экшн бар, который был раньше, если этот метод не вызвать, то могут не работать некоторые фишки, например фуллскрин режим или кнопки на экшн баре, сейчас подробнее расскажу, что это значит.

[8] для начала рассмотрим всю структуру экшнбара всё, кроме тайтла здесь является меню айтемами, сейчас рассмотрим, как они создаются

[9] в активити переопределяем метод onCreateOptionsMenu  здесь нам нужно заинфлейтить менюшку, которую мы хотим видеть в этой активити. Делаем это с помощью класса МенюИнфлейтер, который имеет единственный свой паблик метод для создания меню из файла. Возвращаем тру - говорим, что меню мы создали.
R.menu.root_menu - файл, где мы должны описать экшены.

[10] создаём в ресурсах файл root_menu.xml, назвать можно как угодно
подробней об этом файле ...

[12] Ещё мы знаем, что можно использовать тэги group и menu внутри основной menu, Вот результат, айтемы никак не выделены, но группе мы можем назначить айдишник, и используя группу, можно управлять всеми айтемами в группе сразу, это может быть удобно, если надо прятать или дизейблить сразу несколько айтемов. Сабменю, как видите, открывается просто как новое меню, в ней айтемы, которые мы прописали как сабайтемы.

[13] Чтобы как-то отреагировать на нажатия по экшенам, у нас есть метод onOptionsItemSelected, который мы переопределяем в активити, в этом методе мы получаем айтем, который был нажат, по его айдишнику мы можем понять что это за айтем и что с ним делать.

[14]  Довольно часто в приложениях в экшн баре нужно реализовать поиск, а поиск это такой же меню-айтем, настраивается он несложно, сейчас я покажу пример, он довольно мощный и гораздо более гибкий, по сравнению с тем, что описано на android.developers

[15] делаем сёрч айтем, actionViewClass обратите внимание на нэймспэйс, можно поставить вместо app - android, всё будет собираться, но сам сёрчВью не будет добавлен к этому экшену, и при попытке его использовать получи NPE.
showAsAction показываем, что экшнВью должен быть скрыт по умолчанию

[16] получаем SearchView searchView это вьюха, которая появляется по нажатию поиска и занимает свободное место в экшнбаре. Теперь с этой вьюхой можно делать всё что угодно, например, добавить онКуериТекстЛистенер, у которого будут вызываться колбэки при подтверждении поиска и при изменении строки поиска.
Ещё очень полезный метод setSuggestionsAdapter например мы можем при изменении текста в виджете поиска предлагать какие-нибудь варианты, которые будут отображаться под виджетом. В этот метод передаётся адаптер, который по принципу очень похож на адаптер от ресайкл вью.

[17] Ещё одна фишка экшн бара, это АпНавигейшн, наверняка, вы встречали такую иконку в приложениях.
Чем она отличается от хардварного бэка? По гайдлайнам, нам говорят, что когда мы переходим на какой-нибудь дочерний экранчик, мы должны отобразить на экшнбаре такую стрелочку, которая предоставит нам так называемый АпНивигейшн - возвращение на уровень выше, вот пример - запускаем приложение, переходим со списка бесед на экран конкретной беседы, здесь бэк в экшн баре и хардварный бэк поведут себя одинаково.

[18] на этом примере должно стать понятно чем концептуально отличается поведение хардварного бэка от апНавигейшена, вот с домашнего скрина переходим на какой-то чайлд скрин, потом делаем ещё пару переходов, оказавшись на последнем скрине, если мы будем нажимать бэк - то скрины должны отобразиться в хронологическом порядке, а по нажатию на ап, мы перейдём в пэрент скрин - т.е. на домашний экран.
Это на самом деле всего лишь рекомендация, на самом деле мы можем реализовать какое угодно поведение нашего приложения, делается это так: 

[19] для активити прописывается пэрент через мета дату в манифесте, потом в чайлд активити, мы берём экшн бар и вызываем setDisplayHomeAsUpEnabled этот метод есть только у экшн бара, но не у тулбара. Реагируем на кнопку ап в том же методе, где мы реагируем на другие экшены, R.id.home у нас зарезервирован для апа.
Вообще сейчас этот ап навигейшн в таком виде редко используется, мне ни разу не доводилось имплементить его в таком виде. Обычно можно не прописывать ничего в манифесте и просто самим решать что делать по нажатию на хом баттон в экшн баре.

[20] думаю, всем знаком этот паттерн - навигейшн меню. Как это работает и как связано с экшн баром сейчас узнаем.

[21] Обратите внимание, как поменялся наш лэйаут для активити - теперь рутом стал ДроверЛэйаут, а то что было рутом раньше - контент, теперь первый чайлд внутри НавигейшнДровера, это обязательное требование, вторая вьюха внутри Навигейшена - это и есть та вьюха, которая будет выезжать слева, мы зададим ей ширину не на весь экран, и укажем android:layout_gravity = start можем поставить end, тогда менюшка будет выезжать справа. Можем даже попробовать сделать две вьюхи с разными гравити, как вы думаете, что тогда произойдёт?

[22] Да, это будет работать, иногда мы это используем, например чтобы сделать в приложении дебаг меню. Но больше чем две менюшки мы не сможем указать, проект не соберётся. Как видите, у нас нет привычной кнопочки для открытия меню, чтобы она появилось, нужно добавить немного кода.

[23] вот примерно столько)
Тут мы вынесли в поля активити драверЛэйаут - это, как помните вьюха, которая оборачивает наш контент и вьюху-менюху, ЭкшнБарДраверТогл - это вспомогательный класс, который синхронизирует работу ЭкшнБара и ДраверЛэйаута. Создаём его, передавая ему наш драверЛэйаут, тутже переопределяем колбэки, иногда это бывает очень полезным. далее добавляем его как листенер в драверЛэйаут, и очень важно - вызывать у экшн бара метод сетДисплэйХомЭсАпЭнаблед с параметром тру, иначе кнопки бургер меню показано не будет.
Также нужно переопределить методы onPostCreate и onConfigurationChanged вызываем методы у драверТогла, не буду подробно рассказывать зачем это нужно, в методе обработки нажатий на экшенах, мы первым делом отдаём айтем драверТоглу, если он его обработает, то нам уже ничего делать не надо. 

[24] вот ради чего мы старались - у нас есть кнопочка, по которой открывается меню

[25] мы можем закрывать или открывать менюшку сами из кода, например, если переопределим метод онДраверОпенед и поставим в нём закрытие дравера, то менюшка будет сразу же закрываться или можем делать закрытие по нажатию кнопки.

[26] Вот мы рассмотрели основные фишки экшн бара, но все они используют экшн бар и активити, где профит от тулбара? Почему так важно, что тулбар это вью и мы можем сами решать где в нашей иерархии экрана эту вьюху распологать?

[27] спокойно, вот посмотрите на эту гифку, выглядит круто, правда? экшн бар не получилось бы так анимировать, потому что это кусок фреймворка. 
Наверняка, вы думаете, что реализовать такое очень трудно, и, кстати, у вас в лабе будет что-то похожее. На самом деле всё не так сложно, если вы знаете как работает КоординаторЛэйаут.

CoordinatorLayout это лэйаут, который очень похож на ФреймЛэйаут тем, что в нём нельзя выстраивать вьюхи друг относительно друга, можно только задавать им гравити, но это очень мощная штука, которая умеет координировать вьюхи внутри себя и заставлять их реагировать на какие-то события. Давайте посмотрим на примере.

[28] Сделаем КоординаторЛэйаут нашим рутом, внутри у него будет тулбар и ФлоатингЭкшнБаттон, как видите, никаких неизвестных аттрибутов - гравити, маржин, иконка. Теперь попробуем повешать листенер на эту кнопку, который будет показывать снэкбар. Вот результат, кнопка поднимается вместе с появлением снэкбара, и опускается, когда он исчезает. Магия. 
Возможно, это так работает СнэкБар, он поднимает весь контент над собой? Попробуем провести эксперимент.

[29] добавили текст вью, и вот результат - текст вью никак не реагирует на снэкбар. Очевидно, что дело в этой кнопке

[30] если открыть исходники ФлэатингЭкшнБатон, то увидим анноташку КоординаторЛэйаут.ДефаултБихэвиор, это и есть тот ключевой момент. Бихэвиор определяет, как вьюха будет взаимодействовать с другими вьюхами. Мы можем сами определить поведение для конкретной вьюхи, если мы не хотим, чтобы использовалось дефолтное поведение, которое задано аннотацией в классе, нам нужно указать в разметке наш собственный Бихэвиор.

[31] Два основных метода, которые нужны нам - это депендсОн - возвращаем тру если хотим что-то делать при изменении состояния какого-то типа вьюхи, в данном случае - снэкбара. Этот метод будет вызывать КоординаторЛэйаут, чтобы понять, в каких случаях нужно вызывать второй метод - onDependentViewChanged, если вьюха от которой мы зависим будет перересована, проскролена или свайпнута, то вызовется этот метод. КоординаторЛэйаут отдаст нам свой инстанс, чайлда - нашу кнопку и депенденси - мы знаем, что это снэкбар. Тут мы можем делать всё что угодно с этими объектами, например мы в зависимости от высоты, на которой находится снэкбар будем менять скэйл у флоатинг экшн баттон. Вот как это выглядит.

Конечно, с помощью концепции КоординаторЛэйаута, можно легко имплементить всякие материалДизайн фишки типа скрываемого тулбара при скроллинге и т.д. Но на самом деле, использовать Бихэвиор для Тулбара было бы не очень удобно, потому что пришлось бы переопределять бихэвиор, ставить его тулбару и писать лишний код по реализации поведения тулбара. Чтобы упростить типовые задачи и сделать фишки из матириалДизайн гайдлайнов легко имплементируемыми, придумали АппБарЛэйаут.

[32] Сам по себе это вертикальный ЛинеарЛэйаут, который умеет реагировать на жесты скроллинга, это обеспечивается тем что этот Лэйаут имеет свой дефолтный Бихэвиор, который уже умеет реагировать на некоторые события. Поэтому, если вы решите использовать АппБарЛэйаут не поместив его в КоординаторЛэйаут, то работать он будет как простой ЛинеарЛэйаут и вы ничего интересного не увидите.
Давайте посмотрим как с ним работать и что интересного он позволяет делать.

[33] Возьмём АппБар и завернём в него Тулбар и ТабЛэйаут с двумя табами, кроме АппБара ещё сделаем НестедСкроллВью, в котором будет много текста. 
Тут появились незнакомые аттрибуты. 
app:layout_behavior="@string/appbar_scrolling_view_behavior"
этот атрибут мы на самом деле уже использовали, мы задали аппБарСкролингВьюБихэвиор, это поведение нужно чтобы КоординаторЛэйаут уведомлял наш АппБар, когда с НестедСкроллВью что-то происходит, кроме того, указав этот параметр, КоординаторЛэйаут понимает, что эту вьюху нужно расположить под АппБаром.

[34] вот что будет если мы забудем указать поведение для скроллящейся вьюхи

[35] Если мы уберём скроллФлагс совсем, то вьюха никак не будет реагировать на скроллы контента,
потому что, когда КоординаторЛэйаут детектит изменение состояние скроллящейся вьюхи, он уведомляет об этом АппБар, далее АппБар управляет своими дочерними вьюхами на основе аттрибута app:layout_scrollFlags. У нас на выбор есть несколько значений для этого атрибута, мы использовали scroll|enterAlways 
enterAlways означает что вьюха должна сразу появляться при скролле вниз, без него нам приходилось бы докручивать СкроллВью до самого верха, чтобы увидеть ТулБар.
scroll нужно ставить почти всегда, он означает, что вьюха должна реагировать на скроллы, если её не использовать ни в одной вьюхи, то мы не увидим как АппБар уезжает при скролле контента. Про остальные флаги почитаете сами, когда будете делать лабу.

[36] АппБар позволяет нам указывать вьюхам как реагировать на скроллы какой-либо вьюхи, но всё что мы можем сделать с помощью АппБара это заставить Тулбар и другие Вьюхи внутри АппБара перемещаться по оси Y, но что если нам хочется чего-то более интересного, например, чтобы в АппБаре была картинка, а при скролле она коллапсилась в обычный тулбар? 
Для этого тоже есть вспомогательный класс - CollapsingToolbarLayout
Это обёртка для Тулбара, которая должна быть размещена внутри АппБара.

[37] Лэйаут с использованием КолТулбарЛэйаута будет выглядеть так.
Иерархия ещё больше усложнилась, давайте разбираться.
В руте у нас конечно же КоординаторЛэйаут, без него вообще ничего не будет работать. Дальше АппБар, мы задали ему высоту вручную, это высота будет использоваться для развёрнутого состояния тулбара, АппБар получает уведомления о скролл жестах нашего НестедСкроллВью и отдаёт их в КоллапсингТулбарЛэйаут, получается, что КоллапсингТулбарЛэйаут это единственный чайлд АппБара, и как и у всех чайлдов АппБара ставим ему скроллФлаги - скролл - реагируем на скроллы, exitUntilCollapsed при скролле двигаем чайлда, пока он не схлопнется.
app:contentScrim="@android:color/holo_blue_light" - цвет который будет использоваться при переходе из нормального состояния в схлопнутое, обратите внимание, у меня тулбар должен быть бирюзового цвета, но мы видим голубой.
Дальше мы расположили ИмэджВью, поскольку CollapsingToolbarLayout это потомок FrameLayout, то очень важно в каком порядке мы распологаем элементы внутри, если расположить картинку после тулбара, то её всегда будет видно, даже в коллапсед состоянии.

И для вьюхи и для картинки мы указали аттрибут app:layout_collapseMode он доступен для чайлдов КоллапсингТулБара и задаёт поведение вьюхи при схлапывании КоллапсингТулбара. Есть три варианта: 
COLLAPSING_MODE_PARALAX - паралакс
COLLAPSING_MODE_PIN - вьюха будет прикрепоена к своему месту, пока коллапсингТулбар не будет расвёрнут.
COLLAPSING_MODE_OFF - ко вьюхи не будет иметь никакого коллапс поведения и будет вести себя как нормальная вьюха. 

Используя разные сочетания аттрибута скроллФлагс у АппБара и коллапсМод у КоллапсингТулБара можно добиваться очень интересных поведений вашего лэйаута.
Также можно вспомнить, что АппБар работает только за счёт КоординаторЛэйаута и использует Бихэвиор, который можно переопределить как нам угодно. Я не стал рассматривать этот пример, думаю, на сегодня уже хватит, но если вам интересно, вот почитайте

[38] Recommended:
https://guides.codepath.com/android/Using-the-App-Toolbar - Toolbar Styling
https://guides.codepath.com/android/handling-scrolls-with-coordinatorlayout Coordinator and Scrolls
https://habrahabr.ru/post/270121/ примеры с тулбарами






